// Generated by CoffeeScript 1.6.3
(function() {
  var generateSecureToken,
    __slice = [].slice;

  if (typeof sjcl === "undefined" || sjcl === null) {
    alert('No sjcl library found!');
  }

  if (sjcl.searchable != null) {
    alert('Overriding sjcl.searchable!');
  }

  sjcl.searchable = {};

  sjcl.searchable.tokenize = function(data) {
    data = data.toLowerCase().replace(/[^\w\s]/gi, '');
    data = data.trim().replace(/\s{2,}/g, ' ');
    data = data.split(' ');
    return data;
  };

  generateSecureToken = function(iv, key, n, word) {
    var buff, ct, nEnc, prp, wEnc;
    n = n.toString(16);
    nEnc = '00000000';
    nEnc = nEnc.substring(0, nEnc.length - n.length) + n;
    word = sjcl.codec.hex.fromBits(sjcl.codec.utf8String.toBits(word));
    wEnc = '00000000000000000000000000000000000000000000000000000000';
    wEnc = wEnc.substr(0, wEnc.length - word.length) + word;
    buff = sjcl.hash.sha256.hash(sjcl.codec.hex.toBits(wEnc + nEnc));
    prp = new sjcl.cipher.aes(key);
    ct = sjcl.mode.ccm.encrypt(prp, buff, iv, [], 0);
    ct = sjcl.codec.base64.fromBits(ct);
    return ct;
  };

  sjcl.searchable.secureIndex = function() {
    var c, docs, domain, entry, i, id, ids, index, indexes, iv, key, keys, keystore, l, list, max, n, newId, offset, one, out, rsindex, shuffle, sindex, sum, temp, threshold, token, two, word, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1;
    keystore = arguments[0], max = arguments[1], indexes = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    domain = sjcl.codec.base64.fromBits(sjcl.random.randomWords(4, 0));
    newId = sjcl.codec.base64.fromBits(sjcl.random.randomWords(4, 0));
    iv = sjcl.random.randomWords(4, 0);
    key = sjcl.random.randomWords(8, 10);
    keystore[domain] = sjcl.codec.base64.fromBits(sjcl.bitArray.concat(iv, key));
    keystore[domain] = [indexes.length, keystore[domain]];
    if (indexes[0] instanceof Array) {
      temp = {};
      _ref = indexes[0];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        token = _ref[_i];
        temp[token] = newId;
      }
      indexes[0] = temp;
    }
    index = {};
    for (_j = 0, _len1 = indexes.length; _j < _len1; _j++) {
      list = indexes[_j];
      for (word in list) {
        id = list[word];
        if (index[word] != null) {
          index[word].push(id);
        }
      }
      for (word in list) {
        id = list[word];
        if (index[word] == null) {
          index[word] = [id];
        }
      }
    }
    sindex = {};
    for (word in index) {
      ids = index[word];
      word = word.substr(0, 28);
      offset = 28 - word.length;
      for (n in ids) {
        id = ids[n];
        sindex[generateSecureToken(iv, key, n, word)] = id;
      }
    }
    docs = [];
    for (word in index) {
      ids = index[word];
      for (_k = 0, _len2 = ids.length; _k < _len2; _k++) {
        id = ids[_k];
        if (-1 === docs.indexOf(id)) {
          docs.push(id);
        }
      }
    }
    one = [256, 131072, 50331648];
    two = [256, 65536, 16777216];
    _ref1 = [0, 0, 0], threshold = _ref1[0], sum = _ref1[1], i = _ref1[2];
    while (threshold <= max) {
      threshold += one[i];
      sum += two[i];
      ++i;
    }
    threshold = threshold - one[i - 1];
    sum = sum - two[i - 1];
    sum += Math.floor((max - threshold) / i);
    for (_l = 0, _len3 = docs.length; _l < _len3; _l++) {
      id = docs[_l];
      c = 0;
      for (_m = 0, _len4 = sindex.length; _m < _len4; _m++) {
        entry = sindex[_m];
        if (entry === id) {
          ++c;
        }
      }
      l = sum - c;
      while (l -= 1) {
        sindex[generateSecureToken(iv, key, docs.length + l, '')] = id;
      }
    }
    shuffle = function(array) {
      var N, bytes, cap, j, _ref2;
      i = array.length;
      if (i === 0) {
        return false;
      }
      bytes = Math.ceil(Math.log(array.length) / (8 * Math.log(2)));
      while (i -= 1) {
        N = new sjcl.bn(array.length);
        j = new sjcl.bn(4294967297);
        one = new sjcl.bn(1);
        cap = 4294967296 - (4294967296 % array.length) + 1;
        cap = new sjcl.bn(cap);
        while (0 !== j.greaterEquals(cap)) {
          j = '0x' + sjcl.codec.hex.fromBits(sjcl.random.randomWords(1, 10));
          j = new sjcl.bn(j);
        }
        j = j.mulmod(one, N);
        j = parseInt(j.toString(), 16);
        _ref2 = [array[i], array[j]], array[j] = _ref2[0], array[i] = _ref2[1];
      }
      return array;
    };
    keys = shuffle(Object.keys(sindex));
    rsindex = {};
    for (_n = 0, _len5 = keys.length; _n < _len5; _n++) {
      key = keys[_n];
      rsindex[key] = sindex[key];
    }
    out = {
      newId: newId,
      newDomain: domain,
      index: {
        docs: docs,
        index: rsindex
      }
    };
    return out;
  };

  sjcl.searchable.createQuery = function() {
    var blob, data, dn, i, iv, key, keystore, offset, out, queries, tokens, word, _i, _len, _ref;
    keystore = arguments[0], tokens = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    queries = [];
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
      word = tokens[_i];
      word = word.substr(0, 28);
      offset = 28 - word.length;
      out = {};
      for (dn in keystore) {
        blob = keystore[dn];
        data = sjcl.codec.base64.toBits(blob[1]);
        iv = data.slice(0, 4);
        key = data.slice(4, 12);
        _ref = [0, []], i = _ref[0], out[dn] = _ref[1];
        while (i !== blob[0]) {
          out[dn].push(generateSecureToken(iv, key, i, word));
          ++i;
        }
      }
      queries.push(out);
    }
    return queries;
  };

}).call(this);
